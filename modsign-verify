#!/usr/bin/perl
# 
# Verify kernel module signature generated by /usr/src/linux/scripts/sign-file
# 
# Parts of this script were copied from sign-file, written by David Howels
#

my $USAGE = "Usage: modsign-verify [-v] [-q] [--certificate <x509> | --cert-dir <dir>] <module>\n";

use strict;
use warnings;
use IPC::Open2;
use Getopt::Long;
use File::Temp qw(tempfile);
use bigint;

my $cert;
my $cert_dir;
my $verbose = 1;
GetOptions(
	"certificate=s" => \$cert,
	"cert-dir=s" => \$cert_dir,
	"q|quiet" => sub { $verbose-- if $verbose; },
	"v|verbose" => sub { $verbose++; },
	"h|help" => sub {
		print $USAGE;
		print "Return codes: 0 good signature\n";
		print "              1 bad signature\n";
		print "              2 certificate not found\n";
		print "              3 module not signed\n";
		print "             >3 other error\n";
		exit(0);
	}
) or die($USAGE);

sub _verbose {
	my $level = shift;

	return if $verbose < $level;
	print STDERR @_;
}

sub info    { _verbose(1, @_); }
sub verbose { _verbose(2, @_); }
sub debug   { _verbose(3, @_); }

if (@ARGV > 1) {
	print STDERR "Excess arguments\n";
	die($USAGE);
} elsif (@ARGV < 1) {
	print STDERR "No module supplied\n";
	die($USAGE);
} elsif ($cert && $cert_dir) {
	print STDERR "Please specify either --certificate or --cert-dir, not both.\n";
	die($USAGE);
}
my $module_name = shift(@ARGV);
if (!$cert && !$cert_dir) {
	$cert_dir = "/etc/uefi/certs";
	verbose("Using default certificate directory $cert_dir\n");
}
my @certs;
if ($cert) {
	push(@certs, $cert);
} else {
	my $dh;
	if (!opendir($dh, $cert_dir)) {
		print STDERR "$cert_dir: $!\n";
		exit(2);
	}
	while (my $entry = readdir($dh)) {
		next if $entry =~ /^\./;
		next if !-f "$cert_dir/$entry";
		push(@certs, "$cert_dir/$entry");
	}
	closedir($dh);
	if (!@certs) {
		print STDERR "No certificates found in $cert_dir\n";
		exit(2);
	}
}

###############################################################################
## ASN.1 code copied from kernel-sign-file
###############################################################################

my $x509_certificate = read_file($x509);

my $UNIV = 0 << 6;
my $APPL = 1 << 6;
my $CONT = 2 << 6;
my $PRIV = 3 << 6;

my $CONS = 0x20;

my $BOOLEAN	= 0x01;
my $INTEGER	= 0x02;
my $BIT_STRING	= 0x03;
my $OCTET_STRING = 0x04;
my $NULL	= 0x05;
my $OBJ_ID	= 0x06;
my $UTF8String	= 0x0c;
my $SEQUENCE	= 0x10;
my $SET		= 0x11;
my $UTCTime	= 0x17;
my $GeneralizedTime = 0x18;

my %OIDs = (
    pack("CCC", 85, 4, 3)	=> "commonName",
    pack("CCC", 85, 4, 6)	=> "countryName",
    pack("CCC", 85, 4, 10)	=> "organizationName",
    pack("CCC", 85, 4, 11)	=> "organizationUnitName",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 1, 1) => "rsaEncryption",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 1, 5) => "sha1WithRSAEncryption",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 9, 1) => "emailAddress",
    pack("CCC", 85, 29, 35)	=> "authorityKeyIdentifier",
    pack("CCC", 85, 29, 14)	=> "subjectKeyIdentifier",
    pack("CCC", 85, 29, 19)	=> "basicConstraints",
    # PKCS#7 OID: 1.2.840.113549.1 (iso.member-body.usa.rsadsi.pkcs)
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 7, 1) => "pkcs7-data",
    pack("CCCCCCCCC", 42, 134, 72, 134, 247, 13, 1, 7, 2) => "pkcs7-signed-data",
);

###############################################################################
#
# Extract an ASN.1 element from a string and return information about it.
#
###############################################################################
sub asn1_extract($$@)
{
    my ($cursor, $expected_tag, $optional) = @_;

    return [ -1 ]
	if ($cursor->[1] == 0 && $optional);

    die $x509, ": ", $cursor->[0], ": ASN.1 data underrun (elem ", $cursor->[1], ")\n"
	if ($cursor->[1] < 2);

    my ($tag, $len) = unpack("CC", substr(${$cursor->[2]}, $cursor->[0], 2));

    if ($expected_tag != -1 && $tag != $expected_tag) {
	return [ -1 ]
	    if ($optional);
	die $x509, ": ", $cursor->[0], ": ASN.1 unexpected tag (", $tag,
	" not ", $expected_tag, ")\n";
    }

    $cursor->[0] += 2;
    $cursor->[1] -= 2;

    die $x509, ": ", $cursor->[0], ": ASN.1 long tag\n"
	if (($tag & 0x1f) == 0x1f);
    die $x509, ": ", $cursor->[0], ": ASN.1 indefinite length\n"
	if ($len == 0x80);

    if ($len > 0x80) {
	my $l = $len - 0x80;
	die $x509, ": ", $cursor->[0], ": ASN.1 data underrun (len len $l)\n"
	    if ($cursor->[1] < $l);

	if ($l == 0x1) {
	    $len = unpack("C", substr(${$cursor->[2]}, $cursor->[0], 1));
	} elsif ($l == 0x2) {
	    $len = unpack("n", substr(${$cursor->[2]}, $cursor->[0], 2));
	} elsif ($l == 0x3) {
	    $len = unpack("C", substr(${$cursor->[2]}, $cursor->[0], 1)) << 16;
	    $len = unpack("n", substr(${$cursor->[2]}, $cursor->[0] + 1, 2));
	} elsif ($l == 0x4) {
	    $len = unpack("N", substr(${$cursor->[2]}, $cursor->[0], 4));
	} else {
	    die $x509, ": ", $cursor->[0], ": ASN.1 element too long (", $l, ")\n";
	}

	$cursor->[0] += $l;
	$cursor->[1] -= $l;
    }

    die $x509, ": ", $cursor->[0], ": ASN.1 data underrun (", $len, ")\n"
	if ($cursor->[1] < $len);

    my $ret = [ $tag, [ $cursor->[0], $len, $cursor->[2] ] ];
    $cursor->[0] += $len;
    $cursor->[1] -= $len;

    return $ret;
}

###############################################################################
#
# Retrieve the data referred to by a cursor
#
###############################################################################
sub asn1_retrieve($)
{
    my ($cursor) = @_;
    my ($offset, $len, $data) = @$cursor;
    return substr($$data, $offset, $len);
}


# 2's complement representation of ASN1_INTEGER
sub asn1_int($)
{
    my ($p) = @_;
    my @bytes = unpack("C*", $p);
    my $byte;
    my $neg = 0;
    my $v = 0;

    if (($bytes[0] & 0x80) != 0) {
	    $neg = 1;
	    $bytes[0] &= ~0x80;
    }
    foreach $byte (@bytes) {
	    $v <<= 8;
	    $v += $byte;
    }
    if ($neg) {
	    $v -= (2 ** (8 * scalar(@bytes) - 1));
    };
    return $v;
}

sub asn1_pack($@)
{
    my ($tag, @data) = @_;
    my $ret = pack("C", $tag);
    my $data = join('', @data);
    my $l = length($data);
    return pack("CC", $tag, $l) . $data if $l < 127;
    my $ll = $l >> 8 ? $l >> 16 ? $l >> 24 ? 4 : 3 : 2 : 1;
    return pack("CCa*", $tag, $ll | 0x80,  substr(pack("N", $l), -$ll)) . $data;
}

# OID 1.3.14.3.2.26
# iso.identified-organization.oiw.secsig.algorithms
my @ALGO_OID = (0x2B, 0x0E, 0x03, 0x02);
# OID 2.16.840.1.101.3.4.2
# joint-isu-itu-t.country.usa.organization.gov.iosp.nist_algorithm
my @NIST_ALGO_OID = (0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02);

my %hash_algos = (
	2 => ["sha1", 160/8, @ALGO_OID, 26],
	4 => ["sha256", 256/8, @NIST_ALGO_OID, 1],
	5 => ["sha384", 384/8, @NIST_ALGO_OID, 2],
	6 => ["sha512", 512/8, @NIST_ALGO_OID, 3],
	7 => ["sha224", 224/8, @NIST_ALGO_OID, 4],
);

sub hash_prologue($@)
{
    my ($hash_len, @algo) = @_;
    my $obj = asn1_pack($UNIV | $OBJ_ID, pack("C*", @algo));
    my $seq = asn1_pack($UNIV | $CONS | $SEQUENCE, $obj . pack("CC", $NULL, 0));
    my $tail = pack("CC", $OCTET_STRING, $hash_len);
    my $head = pack("CC", $UNIV | $CONS | $SEQUENCE,
		    length($seq) + length($tail) + $hash_len);
    return $head . $seq . $tail;
}

#
# Function to read the contents of a file into a variable.
#
sub read_file($)
{
    my ($file) = @_;
    my $contents;
    my $len;

    open(FD, "<$file") || die $file;
    binmode FD;
    my @st = stat(FD);
    die $file if (!@st);
    $len = read(FD, $contents, $st[7]) || die $file;
    close(FD) || die $file;
    die "$file: Wanted length ", $st[7], ", got ", $len, "\n"
	if ($len != $st[7]);
    return $contents;
}

sub openssl_pipe($$) {
	my ($input, $cmd) = @_;
	my ($pid, $res);

	$pid = open2(*read_from, *write_to, $cmd) || die $cmd;
	binmode write_to;
	if (defined($input) && $input ne "") {
		print write_to $input || die "$cmd: $!";
	}
	close(write_to) || die "$cmd: $!";

	binmode read_from;
	read(read_from, $res, 4096) || die "$cmd: $!";
	close(read_from) || die "$cmd: $!";
	waitpid($pid, 0) || die;
	die "$cmd died: $?" if ($? >> 8);
	return $res;
}

sub cert_matches {
	my ($cert, $subject_key_id, $subject_name) = @_;

	open(my $pipe, '-|', "openssl", "x509", "-noout", "-text",
		"-inform", "DER", "-in", $cert) or die "openssl x509: $!\n";
	my $found = 0;
	my $found_key_id;
	while (<$pipe>) {
		chomp;
		if (/^\s*X509v3 Subject Key Identifier:/) {
			$found = 1;
			next;
		}
		if ($found) {
			s/[\s:]*//g;
			$found_key_id = pack("H*", $_);
			last;
		}
	}
	if (!$found_key_id) {
		print STDERR "Warning: no subject key identifier in $cert\n";
		return 0;
	}
	debug("$cert has hey id " . unpack("H*", $found_key_id));
	# FIXME: Also check subject_name
	return ($found_key_id eq $subject_key_id);
}

my $module = read_file($module_name);
my $module_len = length($module);
my $magic_number = "~Module signature appended~\n";
my $magic_len = length($magic_number);
my $info_len = 12;

sub eat
{
	my $length = shift;
	if ($module_len < $length) {
		die "Module size too short\n";
	}
	my $res = substr($module, -$length);
	$module = substr($module, 0, $module_len - $length);
	$module_len -= $length;
	return $res;
}

if (eat($magic_len) ne $magic_number) {
	print "$module_name: module not signed\n";
	exit(3);
}
my $info = eat($info_len);
my ($algo, $hash, $id_type, $name_len, $key_len, $sig_len) =
	unpack("CCCCCxxxN", $info);
my $signature = eat($sig_len);
if (unpack("n", $signature) != $sig_len - 2) {
	die "Invalid signature format\n";
}
$signature = substr($signature, 2);
my $key_id = eat($key_len);
my $name = eat($name_len);

if ($algo != 1) {
	die "Unsupported signature algorithm\n";
}
#
# Digest the data
#
my ($prologue, $hash_len, $dgst, @oid);
die "Unsupported hash algorithm\n" if not exists $hash_algos{$hash};

($dgst, $hash_len, @oid) = @{$hash_algos{$hash}};
$prologue = hash_prologue($hash_len, @oid);

verbose("Signed by: $name\n");
verbose("Key id: " . unpack("H*", $key_id) . "\n");
verbose("Hash algorithm: $dgst\n");

my $digest = openssl_pipe($module, "openssl dgst -$dgst -binary");
my $original_message = $prologue . $digest;

for my $cert (sort @certs) {
	debug("Trying $cert\n");
	next unless cert_matches($cert, $key_id, $name);
	verbose("Found certificate $cert\n");

	my ($fh, $filename) = tempfile() or die "Cannot create temporary file: $!\n";
	my $pubkey = openssl_pipe("",
		"openssl x509 -noout -in $cert -inform DER -pubkey");
	print $fh $pubkey;
	close($fh);
	my $verified_message = openssl_pipe($signature,
		"openssl rsautl -verify -inkey $filename -keyform PEM -pubin");
	unlink($filename);
	if ($original_message ne $verified_message) {
		print "$module_name: bad signature\n";
		exit(1);
	}
	print "$module_name: good signature\n";
	exit(0);
}
print "certificate not found\n";
exit(2);
